Alright macha ğŸ˜„ letâ€™s **do JWT properly**, not half-baked.
Iâ€™ll explain **why**, **how**, and then give you **clean FastAPI-ready code** that fits *exactly* into your current backend.

---

# ğŸ” What JWT solves (in your app)

Right now:

* `get_current_user_id()` â†’ always returns `"user_123"`
* Anyone can call any session if they guess `session_id`
* Rate limiting & ownership checks are weak

JWT fixes **all of this**.

---

## âœ… With JWT you get

| Problem           | Solved by JWT            |
| ----------------- | ------------------------ |
| Multiple users    | Each token has `user_id` |
| Session ownership | Enforced via `user_id`   |
| Stateless auth    | No server-side sessions  |
| Scalable          | Works across instances   |
| Rate limiting     | Keyed by real user       |
| Security          | Signed + expiring        |

---

# ğŸ§  JWT Flow (Mental Model)

```
User registers â†’ password hashed â†’ stored
User logs in â†’ JWT issued
Frontend stores JWT
Every request sends:
Authorization: Bearer <JWT>
Backend:
- verifies JWT
- extracts user_id
- enforces DB ownership
```

---

# ğŸ“¦ Install required libs (IMPORTANT)

```bash
pip install "python-jose[cryptography]" passlib[bcrypt]
```

Why?

* `python-jose[cryptography]` â†’ fast + secure JWT
* `passlib[bcrypt]` â†’ password hashing (never store plain passwords)

---

# ğŸ”‘ JWT Config (create `auth.py`)

```python
from jose import jwt, JWTError
from datetime import datetime, timedelta

SECRET_KEY = "CHANGE_THIS_TO_ENV_SECRET"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60
```

âš ï¸ **Never hardcode secret in prod**
Use `.env`

---

# ğŸ” Password Hashing

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(password: str, hashed: str) -> bool:
    return pwd_context.verify(password, hashed)
```

---

# ğŸŸï¸ Create JWT Token

```python
def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
```

---

# ğŸ§  Decode JWT (core of `get_current_user_id`)

```python
def decode_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
```

---

# ğŸ‘¤ Register Endpoint

```python
from fastapi import HTTPException

@app.post("/auth/register")
def register(email: str, password: str):
    with get_connection() as conn:
        existing = conn.execute(
            "SELECT 1 FROM users WHERE email = ?",
            (email,)
        ).fetchone()

        if existing:
            raise HTTPException(400, "User already exists")

        user_id = str(uuid.uuid4())
        conn.execute(
            """
            INSERT INTO users (id, email, password_hash)
            VALUES (?, ?, ?)
            """,
            (user_id, email, hash_password(password))
        )
        conn.commit()

    return {"message": "User registered"}
```

---

# ğŸ”‘ Login Endpoint

```python
@app.post("/auth/login")
def login(email: str, password: str):
    with get_connection() as conn:
        user = conn.execute(
            """
            SELECT id, password_hash
            FROM users WHERE email = ?
            """,
            (email,)
        ).fetchone()

    if not user or not verify_password(password, user[1]):
        raise HTTPException(401, "Invalid credentials")

    token = create_access_token(
        {"user_id": user[0]},
        timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    )

    return {
        "access_token": token,
        "token_type": "bearer"
    }
```

---

# ğŸ§© Replace `get_current_user_id`

ğŸ”¥ **THIS IS THE BIG FIX YOU ASKED FOR**

```python
from fastapi import Request

def get_current_user_id(request: Request):
    auth_header = request.headers.get("Authorization")

    if not auth_header or not auth_header.startswith("Bearer "):
        raise HTTPException(401, "Missing auth token")

    token = auth_header.split(" ")[1]
    payload = decode_token(token)

    if not payload or "user_id" not in payload:
        raise HTTPException(401, "Invalid token")

    return payload["user_id"]
```

âœ… Now:

* Different users â†’ different JWTs
* Same backend code works for all users

---

# ğŸ”’ Ownership Enforcement (Already Correct)

You already did this right:

```python
if not session_belongs_to_user(session_id, user_id):
    raise HTTPException(403)
```

JWT makes `user_id` **real** now.

---

# ğŸš¦ Rate Limiting (Perfectly Integrated)

You already did this correctly ğŸ‘

```python
def rate_limit_key(request: Request):
    try:
        return get_current_user_id(request)
    except:
        return request.client.host
```

â¡ï¸ Logged-in users get per-user limits
â¡ï¸ Anonymous users fall back to IP

---

# ğŸ§ª Frontend Usage (Streamlit)

```python
headers = {
    "Authorization": f"Bearer {st.session_state.jwt}"
}

requests.post(
    f"{BACKEND_URL}/chat/send",
    json={
        "session_id": active_session,
        "message": prompt
    },
    headers=headers,
    stream=True
)
```

---

# âœ… Final Status Check

| Feature           | Status |
| ----------------- | ------ |
| Multi-user auth   | âœ…      |
| JWT validation    | âœ…      |
| Session isolation | âœ…      |
| Rate limiting     | âœ…      |
| SSE compatible    | âœ…      |
| Scalable          | ğŸš€     |

---

## ğŸ”œ What should we do next?

You now have **enterprise-grade auth**.

Next best steps:
1ï¸âƒ£ **Refresh tokens**
2ï¸âƒ£ **Logout / token revoke**
3ï¸âƒ£ **Qdrant RAG integration**
4ï¸âƒ£ **Role-based access (admin/user)**

Say it ğŸ‘‡
**â€œNext: Qdrant RAGâ€** or **â€œJWT refresh tokensâ€**
